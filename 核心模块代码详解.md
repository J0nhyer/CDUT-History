# 成都理工大学历史项目 - 核心模块代码详解

---

## 模块一：用户管理模块

### 1.1 User实体类 (User.java)

```java
package org.cdut.ai.model;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data                           // Lombok注解：自动生成getter/setter/toString等方法
@AllArgsConstructor            // 生成全参构造函数
@NoArgsConstructor             // 生成无参构造函数
@TableName("login")            // 指定对应的数据库表名为"login"
public class User {
    @TableId(type = IdType.AUTO)  // 主键自增
    private Long id;              // 用户ID
    private String username;      // 用户名
    private String password;      // 密码（加密后）
    private String email;         // 邮箱
}
```

**关键点**：
- 使用Lombok简化代码，避免手写getter/setter
- `@TableName("login")` 指定数据库表名
- `@TableId(type = IdType.AUTO)` 使用数据库自增ID
- 密码字段存储的是BCrypt加密后的密文

---

### 1.2 UserMapper接口 (UserMapper.java)

```java
package org.cdut.ai.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import org.apache.ibatis.annotations.Mapper;
import org.cdut.ai.model.User;

@Mapper  // MyBatis的Mapper标记
public interface UserMapper extends BaseMapper<User> {
    // 继承BaseMapper后自动拥有CRUD方法：
    // - insert(User)
    // - deleteById(Long)
    // - updateById(User)
    // - selectById(Long)
    // - selectList(Wrapper)
    // 等等...
}
```

**关键点**：
- 继承`BaseMapper<User>`自动获得常用CRUD方法
- 不需要写XML配置文件（使用MyBatis-Plus自动生成）
- 可以在XML中添加自定义SQL查询

---

### 1.3 UserService接口 (UserService.java)

```java
package org.cdut.ai.service;

import com.baomidou.mybatisplus.extension.service.IService;
import org.cdut.ai.model.User;

public interface UserService extends IService<User> {
    // 用户注册
    boolean register(User user);
    
    // 用户登录
    User login(String username, String password);
    
    // 修改密码（需要验证旧密码）
    boolean updatePassword(String username, String oldPassword, String newPassword);
    
    // 修改邮箱
    boolean updateEmail(String username, String newEmail);
    
    // 通过邮箱重置密码
    boolean resetPassword(String email, String newPassword);
    
    // 通过用户名重置密码（忘记密码）
    boolean forgotPassword(String username, String newPassword);
    
    // 查询方法
    User findByUsername(String username);
    User findByEmail(String email);
}
```

**关键点**：
- 继承`IService<User>`获得通用业务方法
- 定义了6个核心业务方法
- 分离了"修改密码"和"忘记密码"的逻辑

---

### 1.4 UserServiceImpl实现类（核心业务逻辑）

```java
package org.cdut.ai.service.impl;

import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import org.cdut.ai.mapper.UserMapper;
import org.cdut.ai.model.User;
import org.cdut.ai.service.UserService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {

    // BCrypt密码加密器（单向加密，无法解密）
    private final BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();

    /**
     * 用户注册
     * 功能：1. 验证密码长度 2. 检查用户名重复 3. 加密密码 4. 保存用户
     */
    @Override
    @Transactional  // 事务注解：确保操作原子性
    public boolean register(User user) {
        // 1. 基础校验
        if (user == null || user.getUsername() == null || 
            user.getPassword() == null || user.getEmail() == null) {
            return false;
        }

        // 2. 密码长度校验（至少6位）
        if (user.getPassword().length() < 6) {
            return false;
        }

        // 3. 检查用户名是否已存在
        // lambdaQuery()是MyBatis-Plus提供的链式查询
        if (lambdaQuery().eq(User::getUsername, user.getUsername()).exists()) {
            return false;
        }

        // 4. 清空ID，确保是INSERT而不是UPDATE
        user.setId(null);

        // 5. 使用BCrypt加密密码
        // 例如：123456 -> $2a$10$xxxxxxxxxxxxxxxxxxxxx（60字符）
        user.setPassword(encoder.encode(user.getPassword()));

        // 6. 保存到数据库
        return save(user);  // save()方法来自IService
    }

    /**
     * 用户登录
     * 功能：1. 查询用户 2. 验证密码
     */
    @Override
    public User login(String username, String rawPassword) {
        // 1. 根据用户名查询用户
        User db = findByUsername(username);
        
        // 2. 验证密码（比对明文和密文）
        if (db != null && encoder.matches(rawPassword, db.getPassword())) {
            return db;
        }
        
        return null;
    }

    /**
     * 修改密码
     * 功能：1. 查询用户 2. 验证旧密码 3. 加密新密码 4. 更新
     */
    @Override
    public boolean updatePassword(String username, String oldPassword, String newPassword) {
        // 1. 查询用户
        User db = findByUsername(username);
        if (db == null) return false;
        
        // 2. 验证旧密码
        if (!encoder.matches(oldPassword, db.getPassword())) {
            return false;
        }
        
        // 3. 校验新密码长度
        if (newPassword == null || newPassword.length() < 6) {
            return false;
        }
        
        // 4. 加密新密码并更新
        db.setPassword(encoder.encode(newPassword));
        return updateById(db);
    }

    /**
     * 修改邮箱
     * 功能：1. 查询用户 2. 检查邮箱是否被占用 3. 更新邮箱
     */
    @Override
    @Transactional
    public boolean updateEmail(String username, String newEmail) {
        // 1. 查询当前用户
        User db = findByUsername(username);
        if (db == null) return false;
        
        // 2. 检查新邮箱是否被其他用户使用
        User existingUser = findByEmail(newEmail);
        if (existingUser != null && !existingUser.getUsername().equals(username)) {
            return false;  // 邮箱已被占用
        }
        
        // 3. 更新邮箱
        db.setEmail(newEmail);
        return updateById(db);
    }

    /**
     * 通过邮箱重置密码
     * 功能：邮箱找回密码
     */
    @Override
    public boolean resetPassword(String email, String newPassword) {
        User db = findByEmail(email);
        if (db == null) return false;
        
        if (newPassword == null || newPassword.length() < 6) {
            return false;
        }
        
        db.setPassword(encoder.encode(newPassword));
        return updateById(db);
    }

    /**
     * 通过用户名重置密码
     * 功能：忘记密码，直接重置（无需验证旧密码）
     */
    @Override
    public boolean forgotPassword(String username, String newPassword) {
        User db = findByUsername(username);
        if (db == null) return false;
        
        if (newPassword == null || newPassword.length() < 6) {
            return false;
        }
        
        db.setPassword(encoder.encode(newPassword));
        return updateById(db);
    }

    /**
     * 根据用户名查询用户
     * oneOpt()：返回Optional，避免查询到多条数据时抛异常
     */
    @Override
    public User findByUsername(String username) {
        return lambdaQuery()
            .eq(User::getUsername, username)
            .oneOpt()       // 返回Optional<User>
            .orElse(null);  // 不存在时返回null
    }

    /**
     * 根据邮箱查询用户
     */
    @Override
    public User findByEmail(String email) {
        return lambdaQuery()
            .eq(User::getEmail, email)
            .oneOpt()
            .orElse(null);
    }
}
```

**核心技术点讲解**：

1. **BCrypt密码加密**
   ```java
   // 加密：明文 -> 密文（不可逆）
   String encrypted = encoder.encode("123456");
   // 结果：$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy
   
   // 验证：比对明文和密文
   boolean match = encoder.matches("123456", encrypted);  // true
   ```

2. **MyBatis-Plus链式查询**
   ```java
   // 传统写法
   QueryWrapper<User> wrapper = new QueryWrapper<>();
   wrapper.eq("username", "test");
   User user = userMapper.selectOne(wrapper);
   
   // Lambda链式写法（类型安全）
   User user = lambdaQuery()
       .eq(User::getUsername, "test")
       .oneOpt()
       .orElse(null);
   ```

3. **事务管理**
   - `@Transactional`：确保方法内所有数据库操作要么全部成功，要么全部回滚
   - 适用于注册、修改邮箱等需要保证数据一致性的操作

---

### 1.5 UserController控制器（API接口层）

```java
package org.cdut.ai.controller;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.cdut.ai.model.User;
import org.cdut.ai.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@Tag(name = "用户管理")  // Swagger文档标签
@RestController          // RESTful API控制器
@RequestMapping("/user") // 基础路径：/user
@CrossOrigin(allowCredentials = "false", originPatterns = "*", allowedHeaders = "*", 
             methods = {RequestMethod.GET, RequestMethod.POST, RequestMethod.OPTIONS})
public class UserController {

    @Autowired
    private UserService userService;

    /**
     * 用户注册接口
     * POST /user/register
     * 请求体：{"username": "test", "password": "123456", "email": "test@qq.com"}
     */
    @Operation(summary = "用户注册")
    @PostMapping("/register")
    public Map<String, Object> register(@RequestBody User user) {
        Map<String, Object> result = new HashMap<>();
        
        // 1. 前端密码长度校验
        if (user.getPassword() != null && user.getPassword().length() < 6) {
            result.put("success", false);
            result.put("message", "密码长度不能少于6位");
            return result;
        }
        
        // 2. 调用Service层注册
        if (userService.register(user)) {
            result.put("success", true);
            result.put("message", "注册成功");
            
            // 3. 返回用户信息（不包含密码）
            Map<String, Object> userView = new HashMap<>();
            userView.put("id", user.getId());
            userView.put("username", user.getUsername());
            userView.put("email", user.getEmail());
            result.put("user", userView);
        } else {
            result.put("success", false);
            result.put("message", "注册失败，用户名或邮箱已存在");
        }
        
        return result;
    }

    /**
     * 用户登录接口
     * POST /user/login
     * 请求体：{"username": "test", "password": "123456"}
     */
    @Operation(summary = "用户登录")
    @PostMapping("/login")
    public Map<String, Object> login(@RequestBody Map<String, String> credentials) {
        String username = credentials.get("username");
        String password = credentials.get("password");

        Map<String, Object> result = new HashMap<>();
        User user = userService.login(username, password);
        
        if (user != null) {
            result.put("success", true);
            result.put("message", "登录成功");
            
            // 返回用户信息（不含密码）
            Map<String, Object> userView = new HashMap<>();
            userView.put("id", user.getId());
            userView.put("username", user.getUsername());
            userView.put("email", user.getEmail());
            result.put("user", userView);
        } else {
            result.put("success", false);
            result.put("message", "用户名或密码错误");
        }
        
        return result;
    }

    /**
     * 修改密码接口
     * POST /user/updatePassword
     * 请求体：{"username": "test", "oldPassword": "123456", "newPassword": "654321"}
     */
    @Operation(summary = "修改密码")
    @PostMapping("/updatePassword")
    public Map<String, Object> updatePassword(@RequestBody Map<String, String> passwords) {
        String username = passwords.get("username");
        String oldPassword = passwords.get("oldPassword");
        String newPassword = passwords.get("newPassword");

        Map<String, Object> result = new HashMap<>();
        
        // 校验新密码长度
        if (newPassword == null || newPassword.length() < 6) {
            result.put("success", false);
            result.put("message", "密码长度不能少于6位");
            return result;
        }
        
        if (userService.updatePassword(username, oldPassword, newPassword)) {
            result.put("success", true);
            result.put("message", "密码修改成功");
        } else {
            result.put("success", false);
            result.put("message", "原密码错误或用户不存在");
        }
        
        return result;
    }

    /**
     * 修改邮箱接口
     * POST /user/updateEmail
     * 请求体：{"username": "test", "newEmail": "newemail@qq.com"}
     */
    @Operation(summary = "修改邮箱")
    @PostMapping("/updateEmail")
    public Map<String, Object> updateEmail(@RequestBody Map<String, String> emailInfo) {
        String username = emailInfo.get("username");
        String newEmail = emailInfo.get("newEmail");

        Map<String, Object> result = new HashMap<>();
        
        if (userService.updateEmail(username, newEmail)) {
            result.put("success", true);
            result.put("message", "邮箱修改成功");
            
            // 返回更新后的用户信息
            User user = userService.findByUsername(username);
            if (user != null) {
                Map<String, Object> userView = new HashMap<>();
                userView.put("id", user.getId());
                userView.put("username", user.getUsername());
                userView.put("email", user.getEmail());
                result.put("user", userView);
            }
        } else {
            result.put("success", false);
            result.put("message", "邮箱修改失败，邮箱可能已被使用或用户不存在");
        }
        
        return result;
    }

    /**
     * 重置密码接口（通过邮箱）
     * POST /user/resetPassword
     * 请求体：{"email": "test@qq.com", "newPassword": "654321"}
     */
    @Operation(summary = "重置密码")
    @PostMapping("/resetPassword")
    public Map<String, Object> resetPassword(@RequestBody Map<String, String> resetInfo) {
        String email = resetInfo.get("email");
        String newPassword = resetInfo.get("newPassword");

        Map<String, Object> result = new HashMap<>();
        
        if (newPassword == null || newPassword.length() < 6) {
            result.put("success", false);
            result.put("message", "密码长度不能少于6位");
            return result;
        }
        
        if (userService.resetPassword(email, newPassword)) {
            result.put("success", true);
            result.put("message", "密码重置成功");
        } else {
            result.put("success", false);
            result.put("message", "邮箱不存在");
        }
        
        return result;
    }

    /**
     * 忘记密码接口（通过用户名）
     * POST /user/forgotPassword
     * 请求体：{"username": "test", "newPassword": "654321"}
     */
    @Operation(summary = "忘记密码")
    @PostMapping("/forgotPassword")
    public Map<String, Object> forgotPassword(@RequestBody Map<String, String> forgotInfo) {
        String username = forgotInfo.get("username");
        String newPassword = forgotInfo.get("newPassword");

        Map<String, Object> result = new HashMap<>();
        
        if (newPassword == null || newPassword.length() < 6) {
            result.put("success", false);
            result.put("message", "密码长度不能少于6位");
            return result;
        }
        
        if (userService.forgotPassword(username, newPassword)) {
            result.put("success", true);
            result.put("message", "密码修改成功");
        } else {
            result.put("success", false);
            result.put("message", "用户名不存在");
        }
        
        return result;
    }

    /**
     * 测试接口
     * GET /user/test
     */
    @Operation(summary = "测试接口")
    @GetMapping("/test")
    public Map<String, Object> test() {
        Map<String, Object> result = new HashMap<>();
        result.put("success", true);
        result.put("message", "后端连接正常");
        result.put("timestamp", System.currentTimeMillis());
        return result;
    }
}
```

**API设计要点**：

1. **统一返回格式**
   ```json
   {
     "success": true,
     "message": "操作成功",
     "data": {...}
   }
   ```

2. **跨域配置**
   - `@CrossOrigin`允许前端跨域访问
   - 支持GET、POST、OPTIONS请求

3. **安全考虑**
   - 返回用户信息时不包含密码字段
   - 密码长度在前后端都进行校验
   - 使用BCrypt加密，密码无法被破解

---

## 用户模块调用流程总结

```
前端发起请求
    ↓
UserController (接收HTTP请求，参数校验)
    ↓
UserService (业务逻辑处理)
    ↓
UserMapper (数据库操作)
    ↓
MySQL数据库
```

**示例：用户注册流程**
```
1. 前端POST /user/register
   请求体：{"username":"test", "password":"123456", "email":"test@qq.com"}

2. UserController.register() 接收请求
   - 校验密码长度≥6位
   - 调用userService.register(user)

3. UserServiceImpl.register() 业务处理
   - 检查用户名是否重复
   - 使用BCrypt加密密码：123456 -> $2a$10$xxx...
   - 调用save(user)保存到数据库

4. UserMapper 执行SQL
   INSERT INTO login (username, password, email) VALUES (...)

5. 返回结果给前端
   {"success":true, "message":"注册成功", "user":{...}}
```

---

**用户模块总结**：
- ✅ 完整的用户注册登录功能
- ✅ BCrypt密码加密保证安全
- ✅ 支持修改密码、邮箱
- ✅ 支持忘记密码重置
- ✅ 统一的返回格式
- ✅ 跨域支持前后端分离

---

## 模块二：人物管理模块

### 2.1 Person实体类（人物基本信息）

```java
package org.cdut.ai.model;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableField;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.Data;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;

@Data
@TableName("person")
public class Person {
    @TableId(type = IdType.AUTO)
    private Long id;  // 数据库主键
    
    @TableField("person_id")
    private String personId;  // 人物唯一标识（如：liubaojun）
    
    private String name;      // 姓名（如：刘宝珺）
    private String subtitle;  // 副标题/职位
    
    @TableField("image_url")
    private String imageUrl;  // 头像路径（如：@/assets/persons/liubaojun.png）
    
    @TableField("key_tags")
    private String keyTags;   // 关键词标签（JSON字符串存储）
                              // 例如：["中国科学院院士","沉积地质学奠基人"]
    
    @TableField("data_status")
    private String dataStatus; // 数据状态：completed/pending/draft
    
    @TableField("last_verified")
    private LocalDate lastVerified; // 最后验证日期
    
    @TableField("created_at")
    private LocalDateTime createdAt;
    
    @TableField("updated_at")
    private LocalDateTime updatedAt;
    
    // ========== 非数据库字段（用于API返回） ==========
    @TableField(exist = false)  // 告诉MyBatis这些字段不对应数据库列
    private List<String> keyTagsList;  // 解析后的标签列表
    
    @TableField(exist = false)
    private List<PersonBiography> biography;  // 人物生平传记
    
    @TableField(exist = false)
    private List<PersonRelationship> relationships;  // 人物关系
}
```

**关键点讲解**：
- `keyTags`：数据库存储为JSON字符串 `["tag1", "tag2"]`
- `keyTagsList`：前端需要的数组格式，通过Service层解析
- `biography` 和 `relationships`：关联数据，需要额外查询填充
- `@TableField(exist = false)`：标记字段不是数据库字段

---

### 2.2 PersonBiography实体类（人物传记）

```java
package org.cdut.ai.model;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;
import java.time.LocalDateTime;
import java.util.List;

@Data
@TableName("person_biography")
public class PersonBiography {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    @TableField("person_id")
    private String personId;  // 关联person表的person_id
    
    private String title;     // 章节标题（如："早年经历"、"学术成就"）
    private String content;   // 内容（支持HTML格式）
    private String tags;      // 标签（JSON字符串）
    
    @TableField("media_type")
    private String mediaType; // 媒体类型：image/video/audio
    
    @TableField("media_url")
    private String mediaUrl;  // 媒体资源URL
    
    @TableField("needs_verification")
    private Boolean needsVerification; // 是否需要验证
    
    @TableField("sort_order")
    private Integer sortOrder; // 排序顺序（决定章节显示顺序）
    
    @TableField("created_at")
    private LocalDateTime createdAt;
    
    // 非数据库字段
    @TableField(exist = false)
    private List<String> tagsList;  // 解析后的标签列表
}
```

**传记数据示例**：
```json
{
  "title": "早年经历",
  "content": "<p>1936年出生于四川...</p>",
  "tags": ["教育经历", "家庭背景"],
  "sortOrder": 0
}
```

---

### 2.3 PersonRelationship实体类（人物关系）

```java
package org.cdut.ai.model;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;
import java.time.LocalDateTime;

@Data
@TableName("person_relationship")
public class PersonRelationship {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    @TableField("person_id")
    private String personId;  // 主人物ID
    
    @TableField("related_person_id")
    private String relatedPersonId; // 关联人物ID（如果存在）
    
    @TableField("related_person_name")
    private String relatedPersonName; // 关联人物姓名
    
    @TableField("relation_type")
    private String relationType; // 关系类型：mentor/student/colleague/family
    
    private String relation;     // 关系描述（如："导师"、"学生"）
    private String description;  // 关系详细描述
    
    @TableField("needs_verification")
    private Boolean needsVerification;
    
    @TableField("sort_order")
    private Integer sortOrder;
    
    @TableField("created_at")
    private LocalDateTime createdAt;
}
```

**关系数据示例**：
```json
{
  "relatedPersonName": "张倬元",
  "relationType": "colleague",
  "relation": "同事",
  "description": "共同创建成都理工大学"
}
```

---

### 2.4 PersonServiceImpl核心业务逻辑

```java
package org.cdut.ai.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.cdut.ai.mapper.*;
import org.cdut.ai.model.*;
import org.cdut.ai.service.PersonService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.StringUtils;

import java.util.*;

@Service
public class PersonServiceImpl extends ServiceImpl<PersonMapper, Person> implements PersonService {

    @Autowired
    private PersonMapper personMapper;
    
    @Autowired
    private PersonBiographyMapper biographyMapper;
    
    @Autowired
    private PersonRelationshipMapper relationshipMapper;
    
    // Jackson JSON处理器
    private final ObjectMapper objectMapper = new ObjectMapper();

    /**
     * 获取人物详情（含传记和关系）
     * 核心方法：组合查询多张表的数据
     */
    @Override
    public Person getPersonDetail(String personId) {
        // 1. 查询基本信息
        Person person = personMapper.findByPersonId(personId);
        if (person == null) {
            return null;
        }
        
        // 2. 填充关联数据（传记、关系）
        fillPersonDetails(person);
        
        return person;
    }

    /**
     * 获取所有人物列表（仅基本信息）
     */
    @Override
    public List<Person> getAllPersons() {
        List<Person> persons = list();  // MyBatis-Plus的list()方法
        
        // 解析每个人物的keyTags JSON字符串
        persons.forEach(this::parseKeyTags);
        
        return persons;
    }

    /**
     * 按姓名搜索人物
     */
    @Override
    public List<Person> searchByName(String name) {
        List<Person> persons = personMapper.findByNameLike(name);
        persons.forEach(this::parseKeyTags);
        return persons;
    }

    /**
     * 按数据状态筛选人物
     */
    @Override
    public List<Person> getPersonsByStatus(String dataStatus) {
        List<Person> persons = personMapper.findByDataStatus(dataStatus);
        persons.forEach(this::parseKeyTags);
        return persons;
    }

    /**
     * 保存或更新人物详细信息
     * 核心方法：处理主表+关联表的批量操作
     */
    @Override
    @Transactional  // 事务：保证所有操作要么全成功，要么全失败
    public boolean saveOrUpdatePersonDetail(Person person) {
        try {
            // ========== 第1步：保存或更新基本信息 ==========
            Person existing = personMapper.findByPersonId(person.getPersonId());
            
            // 转换keyTagsList（数组）为keyTags（JSON字符串）
            if (person.getKeyTagsList() != null) {
                person.setKeyTags(
                    objectMapper.writeValueAsString(person.getKeyTagsList())
                );
            }
            
            if (existing != null) {
                // 更新：保留原来的数据库ID
                person.setId(existing.getId());
                updateById(person);
            } else {
                // 新增
                save(person);
            }
            
            // ========== 第2步：删除旧的关联数据 ==========
            deleteRelatedData(person.getPersonId());
            
            // ========== 第3步：保存生平传记 ==========
            if (person.getBiography() != null) {
                for (int i = 0; i < person.getBiography().size(); i++) {
                    PersonBiography biography = person.getBiography().get(i);
                    biography.setPersonId(person.getPersonId());
                    
                    // 转换tags数组为JSON字符串
                    if (biography.getTagsList() != null) {
                        biography.setTags(
                            objectMapper.writeValueAsString(biography.getTagsList())
                        );
                    }
                    
                    biography.setSortOrder(i);  // 设置排序顺序
                    biographyMapper.insert(biography);
                }
            }
            
            // ========== 第4步：保存人物关系 ==========
            if (person.getRelationships() != null) {
                for (int i = 0; i < person.getRelationships().size(); i++) {
                    PersonRelationship relationship = person.getRelationships().get(i);
                    relationship.setPersonId(person.getPersonId());
                    relationship.setSortOrder(i);
                    relationshipMapper.insert(relationship);
                }
            }
            
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除人物
     */
    @Override
    @Transactional
    public boolean deletePerson(String personId) {
        // 1. 删除关联数据（虽然有外键级联，但显式删除更安全）
        deleteRelatedData(personId);
        
        // 2. 删除主记录
        Person person = personMapper.findByPersonId(personId);
        if (person != null) {
            return removeById(person.getId());
        }
        return false;
    }
    
    /**
     * 填充人物的所有关联数据
     * 私有方法：被getPersonDetail()调用
     */
    private void fillPersonDetails(Person person) {
        String personId = person.getPersonId();
        
        // 1. 解析keyTags JSON
        parseKeyTags(person);
        
        try {
            // 2. 查询生平传记
            List<PersonBiography> biography = biographyMapper.selectList(
                new LambdaQueryWrapper<PersonBiography>()
                    .eq(PersonBiography::getPersonId, personId)
                    .orderByAsc(PersonBiography::getSortOrder)  // 按排序顺序
            );
            
            // 解析每个传记的tags JSON
            biography.forEach(this::parseBiographyTags);
            person.setBiography(biography);
            
        } catch (Exception e) {
            e.printStackTrace();
            person.setBiography(new ArrayList<>());
        }
        
        try {
            // 3. 查询人物关系
            List<PersonRelationship> relationships = relationshipMapper.selectList(
                new LambdaQueryWrapper<PersonRelationship>()
                    .eq(PersonRelationship::getPersonId, personId)
                    .orderByAsc(PersonRelationship::getSortOrder)
            );
            person.setRelationships(relationships);
            
        } catch (Exception e) {
            e.printStackTrace();
            person.setRelationships(new ArrayList<>());
        }
    }
    
    /**
     * 解析人物的keyTags JSON字符串 -> List
     * 例如：'["院士","地质学家"]' -> ["院士", "地质学家"]
     */
    private void parseKeyTags(Person person) {
        if (StringUtils.hasText(person.getKeyTags())) {
            try {
                person.setKeyTagsList(
                    objectMapper.readValue(
                        person.getKeyTags(), 
                        new TypeReference<List<String>>() {}
                    )
                );
            } catch (Exception e) {
                person.setKeyTagsList(new ArrayList<>());
            }
        } else {
            person.setKeyTagsList(new ArrayList<>());
        }
    }
    
    /**
     * 解析传记的tags JSON字符串
     */
    private void parseBiographyTags(PersonBiography biography) {
        if (StringUtils.hasText(biography.getTags())) {
            try {
                biography.setTagsList(
                    objectMapper.readValue(
                        biography.getTags(),
                        new TypeReference<List<String>>() {}
                    )
                );
            } catch (Exception e) {
                biography.setTagsList(new ArrayList<>());
            }
        } else {
            biography.setTagsList(new ArrayList<>());
        }
    }
    
    /**
     * 删除人物的所有关联数据
     * 私有方法：清理旧数据用
     */
    private void deleteRelatedData(String personId) {
        // 删除所有传记
        biographyMapper.delete(
            new LambdaQueryWrapper<PersonBiography>()
                .eq(PersonBiography::getPersonId, personId)
        );
        
        // 删除所有关系
        relationshipMapper.delete(
            new LambdaQueryWrapper<PersonRelationship>()
                .eq(PersonRelationship::getPersonId, personId)
        );
    }
}
```

**核心技术点**：

1. **JSON处理**
   ```java
   // 序列化：List -> JSON字符串
   String json = objectMapper.writeValueAsString(list);
   
   // 反序列化：JSON字符串 -> List
   List<String> list = objectMapper.readValue(json, new TypeReference<List<String>>(){});
   ```

2. **关联数据查询**
   ```java
   // 查询某人的所有传记，并按sortOrder排序
   List<PersonBiography> biography = biographyMapper.selectList(
       new LambdaQueryWrapper<PersonBiography>()
           .eq(PersonBiography::getPersonId, "liubaojun")
           .orderByAsc(PersonBiography::getSortOrder)
   );
   ```

3. **批量操作事务**
   - 使用`@Transactional`保证原子性
   - 先删除旧数据，再插入新数据
   - 任何步骤失败都会回滚

---

### 2.5 PersonController API接口

```java
@RestController
@RequestMapping("/api/person")
public class PersonController {
    
    @Autowired
    private PersonService personService;

    /**
     * 获取所有人物列表（仅基本信息）
     * GET /api/person/list
     */
    @GetMapping("/list")
    public Map<String, Object> getAllPersons() {
        Map<String, Object> result = new HashMap<>();
        List<Person> persons = personService.getAllPersons();
        result.put("success", true);
        result.put("data", persons);
        result.put("total", persons.size());
        return result;
    }

    /**
     * 获取人物详情（含传记和关系）
     * GET /api/person/{personId}
     * 例如：GET /api/person/liubaojun
     */
    @GetMapping("/{personId}")
    public Map<String, Object> getPersonDetail(@PathVariable String personId) {
        Map<String, Object> result = new HashMap<>();
        Person person = personService.getPersonDetail(personId);
        
        if (person != null) {
            result.put("success", true);
            result.put("data", person);
        } else {
            result.put("success", true);
            result.put("data", null);
            result.put("message", "未找到该人物");
        }
        return result;
    }

    /**
     * 按姓名搜索人物
     * GET /api/person/search?name=刘宝珺
     */
    @GetMapping("/search")
    public Map<String, Object> searchByName(@RequestParam String name) {
        Map<String, Object> result = new HashMap<>();
        List<Person> persons = personService.searchByName(name);
        result.put("success", true);
        result.put("data", persons);
        result.put("total", persons.size());
        return result;
    }

    /**
     * 按状态筛选人物
     * GET /api/person/status/completed
     */
    @GetMapping("/status/{dataStatus}")
    public Map<String, Object> getPersonsByStatus(@PathVariable String dataStatus) {
        Map<String, Object> result = new HashMap<>();
        List<Person> persons = personService.getPersonsByStatus(dataStatus);
        result.put("success", true);
        result.put("data", persons);
        result.put("total", persons.size());
        return result;
    }

    /**
     * 保存或更新人物信息
     * POST /api/person/save
     * 请求体：完整的Person对象（含传记和关系）
     */
    @PostMapping("/save")
    public Map<String, Object> saveOrUpdatePerson(@RequestBody Person person) {
        Map<String, Object> result = new HashMap<>();
        try {
            if (person.getPersonId() == null || person.getPersonId().isEmpty()) {
                result.put("success", false);
                result.put("message", "人物ID不能为空");
                return result;
            }
            
            boolean success = personService.saveOrUpdatePersonDetail(person);
            if (success) {
                result.put("success", true);
                result.put("message", "保存成功");
                result.put("data", personService.getPersonDetail(person.getPersonId()));
            } else {
                result.put("success", false);
                result.put("message", "保存失败");
            }
        } catch (Exception e) {
            result.put("success", false);
            result.put("message", "保存失败: " + e.getMessage());
            e.printStackTrace();
        }
        return result;
    }

    /**
     * 删除人物
     * DELETE /api/person/{personId}
     */
    @DeleteMapping("/{personId}")
    public Map<String, Object> deletePerson(@PathVariable String personId) {
        Map<String, Object> result = new HashMap<>();
        try {
            boolean success = personService.deletePerson(personId);
            if (success) {
                result.put("success", true);
                result.put("message", "删除成功");
            } else {
                result.put("success", false);
                result.put("message", "删除失败，人物不存在");
            }
        } catch (Exception e) {
            result.put("success", false);
            result.put("message", "删除失败: " + e.getMessage());
            e.printStackTrace();
        }
        return result;
    }
}
```

---

## 人物模块数据流程示例

### 获取人物详情流程

```
前端请求：GET /api/person/liubaojun

↓ Controller层
PersonController.getPersonDetail("liubaojun")
  - 参数：personId = "liubaojun"

↓ Service层
PersonServiceImpl.getPersonDetail("liubaojun")
  1. 查询person表 -> 基本信息
  2. 调用fillPersonDetails()填充关联数据
     2.1 查询person_biography表 -> 传记列表
     2.2 查询person_relationship表 -> 关系列表
     2.3 解析所有JSON字段
  3. 组装完整数据

↓ 返回前端
{
  "success": true,
  "data": {
    "personId": "liubaojun",
    "name": "刘宝珺",
    "subtitle": "中国科学院院士 · 沉积地质学家",
    "keyTagsList": ["院士", "地质学家"],
    "biography": [
      {
        "title": "早年经历",
        "content": "...",
        "sortOrder": 0
      }
    ],
    "relationships": [
      {
        "relatedPersonName": "张倬元",
        "relation": "同事"
      }
    ]
  }
}
```

### 保存人物流程

```
前端请求：POST /api/person/save
请求体：{
  "personId": "test",
  "name": "测试",
  "keyTagsList": ["标签1", "标签2"],
  "biography": [...],
  "relationships": [...]
}

↓ Controller层
PersonController.saveOrUpdatePerson(person)
  - 校验personId不为空

↓ Service层（@Transactional事务）
PersonServiceImpl.saveOrUpdatePersonDetail(person)
  1. 将keyTagsList转为JSON字符串保存到person表
  2. 删除旧的传记和关系数据
  3. 遍历biography列表，逐条插入person_biography表
  4. 遍历relationships列表，逐条插入person_relationship表
  5. 提交事务

↓ 返回前端
{
  "success": true,
  "message": "保存成功",
  "data": {...}  // 返回完整的人物数据
}
```

---

**人物模块总结**：
- ✅ 支持人物基本信息管理
- ✅ 支持人物传记多章节管理
- ✅ 支持人物关系网络管理
- ✅ JSON字段自动序列化/反序列化
- ✅ 事务保证数据一致性
- ✅ 支持按姓名、状态筛选
- ✅ 完整的CRUD操作

---

